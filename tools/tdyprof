#!/usr/bin/env python3

# Use this script with the CSV profile data generated by -tdy_timers.
# You can run it with various options to inspect profiling results.

def usage():
    print('tdyprof: Usage:')
    print('tdyprof <profile.csv> <command> [options]\n')
    print('Commands are:')
    print('  topN [rank=P]')
    print('  - Show the N measurements that take the most time, optionally')
    print('    specifying the rank to which they belong.')
    print('  botN [rank=P]')
    print('  - Show the N measurements that take the least time, optionally')
    print('    specifying the rank to which they belong.')
    print('  match <pattern> [rank=P]')
    print('  - Show the ranking of measurements matching the given pattern,')
    print('    optionally specifying the rank to which it belongs.')
    exit()

def parse_csv(csv_file):
    import io, csv
    with open(csv_file, 'r') as f:
        data = csv.DictReader(f)
        rows = [r for r in data]
        return rows

def prune_rows(rows):
    # Prunes extraneous Stage information and summary entries from rows.
    return [r for r in rows if float(r['Time']) > 0 and
            r['Event Name'] != 'summary']

def gather_topN(data, N, rank):
    # If a rank was specified, sort the rows in descending order by time.
    if rank is not None and rank >= 0:
        sorted_rows = sorted([r for r in data if int(r['Rank']) == rank],
                             key=lambda row: float(row['Time']),
                             reverse=True)
    # Otherwise, pick out the max times for each event.
    else:
        max_time_rows = []
        rank0_rows = [r for r in data if int(r['Rank']) == 0]
        for row in rank0_rows:
            all_ranks = [r for r in data
                         if r['Stage Name'] == row['Stage Name']
                         and r['Event Name'] == row['Event Name']]
            max_time_rows.append(sorted(all_ranks,
                                        key=lambda r: float(r['Time']),
                                        reverse=True)[0])
        sorted_rows = sorted(max_time_rows,
                             key=lambda row: float(row['Time']),
                             reverse=True)
    return prune_rows(sorted_rows)

def topN(data, N, options):
    if len(data) == 0:
        return
    rank = None
    if 'rank' in options:
        rank = int(options['rank'])
    rows = gather_topN(data, N, rank)

    # Report the top N results.
    rank_str = '(max across ranks)' if rank is None else 'for rank "%d"'%rank
    print('tdyprof: showing top %d hits %s:'%(N, rank_str))
    col_names = ['Stage Name', 'Event Name', 'Time', 'FLOP']
    print('{: >20} {: >40} {: >10} {: >16}'.format(*col_names))
    for i in range(N):
        row = [rows[i][c][:40] for c in col_names]
        print('{: >20} {: >40} {: >10} {: >16}'.format(*row))

def botN(data, N, options):
    if len(data) == 0:
        return
    rank = None
    if 'rank' in options:
        rank = int(options['rank'])
    rows = gather_topN(data, N, rank)
    rows.reverse()

    # Report the bottom N results.
    rank_str = '(max across ranks)' if rank is None else 'for rank "%d"'%rank
    print('tdyprof: showing bottom %d hits %s:'%(N, rank_str))
    col_names = ['Stage Name', 'Event Name', 'Time', 'FLOP']
    print('{: >20} {: >40} {: >10} {: >16}'.format(*col_names))
    for i in range(N):
        row = [rows[i][c][:40] for c in col_names]
        print('{: >20} {: >40} {: >10} {: >16}'.format(*row))

def match(data, pattern, options):
    if len(data) == 0:
        return
    rank = None
    if 'rank' in options:
        rank = int(options['rank'])
    rows = gather_topN(data, len(data), rank)
    matches = []
    for i in range(len(rows)):
        if pattern in rows[i]['Event Name']:
            matches.append(i)
    results = []
    for m in matches:
        rec = rows[m]
        rec['Ranking'] = str(m+1)
        results.append(rec)

    # Report the rankings of the matches.
    rank_str = '' if rank is None else 'for rank "%d"'%rank
    print('tdyprof: showing matches for "%s"%s:'%(pattern, rank_str))
    col_names = ['Ranking', 'Stage Name', 'Event Name', 'Time', 'FLOP']
    print('{: >10} {: >20} {: >40} {: >10} {: >16}'.format(*col_names))
    for i in range(len(results)):
        row = [results[i][c][:40] for c in col_names]
        print('{: >10} {: >20} {: >40} {: >10} {: >16}'.format(*row))

def main():
    import sys
    if len(sys.argv) < 3:
        usage()

    # The first two arguments are always the CSV file and the command.
    csv_file = sys.argv[1]
    command = sys.argv[2]

    data = parse_csv(csv_file)

    # Gather any command-specific options
    options = {}
    for arg in sys.argv[3:]:
        if '=' in arg:
            k, v = arg.split('=')
            options[k] = v

    # Execute the given command with its given args/options.
    if command.startswith('top'):
        N = min(int(command[3:]), len(data))
        topN(data, N, options)
    elif command.startswith('bot'):
        N = min(int(command[3:]), len(data))
        botN(data, N, options)
    elif command == 'match':
        if len(sys.argv) < 4:
            print('tdyprof: missing pattern for match command.')
        else:
            pattern = sys.argv[3]
            match(data, pattern, options)
    else:
        print('tdyprof: unrecognized command: %s'%command)

if __name__ == '__main__':
    main()
