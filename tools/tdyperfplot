#!/usr/bin/env python3

# This script generates plots for scaling studies. Use it with CSV profile
# data generated by -tdy_timers.

import math
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from optparse import OptionParser

def usage():
    print('tdyperfplot: Usage:')
    print('tdyperfplot [options] <profile1.csv> <profile2.csv> ... <profileN.csv>\n')
    print('Options:')
    print('  -s stage: Plot measurements for a specific logging stage.')
    exit()

def parse_csv(csv_file):
    import io, csv
    with open(csv_file, 'r') as f:
        data = csv.DictReader(f)
        rows = [r for r in data]
        return rows

def extract_metadata(rows):
    md_row = None
    md = {}
    for i, row in enumerate(rows):
        if row['Stage Name'] == 'METADATA':
            md_row = i
    if not md_row:
        raise RuntimeError('Invalid profile report!')
    md_names = [v for v in rows[md_row+1].values() if v is not None]
    for i, v in enumerate(rows[md_row+2].values()):
        if v is not None:
            md[md_names[i]] = v
    rows = rows[:md_row]
    return rows, md

def plot_profiles(files, options):
    stage = options.stage
    all_data = {} # maps numbers of cells to datasets
    colors = {}   # produces colors for mode+method combination
    available_colors = list(mcolors.TABLEAU_COLORS)
    scale_factor = 5

    # Gather throughput data for the plot from the given files.
    for f in files:
        print("Parsing %s"%f)
        prof = parse_csv(f)
        prof, md = extract_metadata(prof)

        # Get the important metadata. We break the datasets into plots of
        # different numbers of cells.
        mode = md['Mode']
        method = md['Method']
        nproc = int(md['NumProc'])
        ncells = int(md['NumCells'])
        if ncells not in all_data:
            all_data[ncells] = {}

        label = '%s %s'%(mode, method)
        print('%d procs, %d cells, %s'%(nproc, ncells, label))
        if not label in colors:
            colors[label] = available_colors[len(colors)]
        color = colors[label]

        if label not in all_data[ncells]:
            d = {
                'mode': mode,
                'method': method,
                'color': [],
                'size': [],
                'x': [],
                'y': [],
            }
            all_data[ncells][label] = d

        # Extract the data.
        if stage: # time for a particular stage
            x = sum([float(r['Time']) for r in prof
                     if r['Stage Name'] == stage
                     and r['Event Name'] == 'summary'
                     and r['Rank'] == '0'])
        else: # total time
            x = sum([float(r['Time']) for r in prof
                     if r['Event Name'] == 'summary'
                     and r['Rank'] == '0'])
        y = ncells/x
        size = (nproc * scale_factor)**2
        d = all_data[ncells][label]
        d['x'].append(x)
        d['y'].append(y)
        d['color'].append(color)
        d['size'].append(size)

    # Generate all the plots.
    i = 0
    for ncells, data in all_data.items():
        if len(data) > 1:
            if stage:
                title = '%s Scaling (%d cells)'%(stage, ncells)
            else:
                title = 'TDycore Scaling (%d cells)'%ncells
        else:
            # Everything's running in the same mode, so strip it out of
            # the labels and stick it into the title.
            relabeled_data = {}
            for label, series in data.items():
                mode = series['mode']
                if stage:
                    title = '%s Scaling (%s, %d cells)'%(stage, series['mode'], ncells)
                else:
                    title = 'TDycore Scaling (%s, %d cells)'%(series['mode'], ncells)
                new_label = label.replace('%s '%mode, '')
                relabeled_data[new_label] = data[label]
            data = relabeled_data
        plt.figure(i)
        plt.title(title)
        plt.xlabel('Time [s]')
        plt.ylabel('Throughput [# cells/s]')
        for label, series in data.items():
            print(label, series)
            plt.scatter(series['x'],
                        series['y'],
                        s=series['size'],
                        c=series['color'],
                        label=label,
                        marker='o')
        i += 1
    plt.show()

def main():
    import sys
    if len(sys.argv) < 2:
        usage()

    parser = OptionParser()
    parser.add_option("-s", "--stage", dest="stage", default=None,
                      help="Logging stage for scaling study")

    options, args = parser.parse_args()
    files = args

    if len(files) < 1:
      print("tdyperfplot: need at least one profile.")
      exit()

    plot_profiles(files, options)

if __name__ == '__main__':
    main()
